---
title: "Results"
author: "KW"
date: "`r Sys.Date()`"
output: html_document
---

PURPOSE: Chapters 4 and 5. After DGP is run and executed, tables are created for results. Import these to make display assets and run ANOVAs.  

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
```

```{r pkgs}
pacman::p_load(
  broom,
  dplyr,
  effectsize,
  forcats,
  # furrr,
  ggforce,
  ggplot2,
  ggrepel,
  glue,
  gt,
  here,
  lubridate,
  purrr,
  readr,
  scales,
  # tibble,
  tidyr)

dt <- lubridate::today()
#dir.create("results", showWarnings = FALSE)
#dir.create("figures", showWarnings = FALSE)

conflicted::conflicts_prefer(
  dplyr::select(),
  dplyr::filter()
)

# Save csv and RDS to results directory
fn_save_results <- function(df) {
  name <- deparse(substitute(df))
  saveRDS(df, here::here(paste0("results/",name,"_",dt, ".RDS")))
  write.csv(df,here::here(paste0("results/",name,"_",dt, ".csv")))
}

```  

```{r get_data}
all_df <- readRDS(here::here("results/all_df_2026-02-06.RDS"))
summ_gamma <- readRDS(here::here("results/summ_gamma_2026-02-09.RDS"))
summ_grid  <- readRDS(here::here("results/summ_grid_2026-02-09.RDS"))
all_df_gamma <- readRDS(here::here("results/all_df_gamma_2026-02-09.RDS"))
all_df_att   <- readRDS(here::here("results/all_df_att_2026-02-09.RDS"))

```


## 

```{r descr}
# Focus on the Gamma Part-2 interaction (can switch to "ATT" later)

# ---- Bias (overall) ----
# mean_bias is average SIGNED bias; preserves direction of estimator's errors, where neg is systematic underestimation and positive is systematic overestimation and opposing signs are going to cancel each other out. 
# The mean_abs_bias is the average absolute magnitude of the bias, which measures how far the estimator is from the truth on average. Does not allow pos/neg to cancel each other out. Always >=0. Larger values indicate more inconsistent or unstable estimation. 
# Mean_abs_bias captures estimator error magnitude, while mean_bias captures estimator direction. mean_bias answers if treatment method systematically over or under estimates the effect, while mean_abs_bias answers how large are the estimation errors, regardless of direction. A method an have a mean bias of 0 and look good but actually perform poorly when you see a large mean_abs_bias because that means it swings pos in some directions, negative in others. 

# Helper for quantiles (same as before)
q_fun <- function(x, p) stats::quantile(x, probs = p, na.rm = TRUE, type = 7)

tab_bias_descr <- summ_gamma %>%
  dplyr::group_by(treatment) %>%
  dplyr::summarise(
    scenarios        = dplyr::n(),
    mean_bias        = mean(bias, na.rm = TRUE),
    sd_bias          = sd(bias, na.rm = TRUE),
    median_bias      = median(bias, na.rm = TRUE),
    mad_bias         = mad(bias, na.rm = TRUE),
    min_bias         = min(bias, na.rm = TRUE),
    q1_bias          = q_fun(bias, 0.25),
    q3_bias          = q_fun(bias, 0.75),
    iqr_bias         = q3_bias - q1_bias,
    max_bias         = max(bias, na.rm = TRUE),
    mean_abs_bias    = mean(abs(bias), na.rm = TRUE),
    share_bias_neg   = mean(bias < 0, na.rm = TRUE),
    share_bias_pos   = mean(bias > 0, na.rm = TRUE),
    .groups = "drop"
  )

gt_bias_descr <- tab_bias_descr %>%
  dplyr::mutate(
    dplyr::across(
      c(mean_bias, sd_bias, median_bias, mad_bias, min_bias, q1_bias, 
        q3_bias, iqr_bias, max_bias, mean_abs_bias),
      ~ scales::number(.x, accuracy = 0.0001)
    ),
    share_bias_neg = scales::percent(share_bias_neg, accuracy = 0.1),
    share_bias_pos = scales::percent(share_bias_pos, accuracy = 0.1)
  ) %>%
  gt::gt() %>%
  gt::tab_header(
    title = "Gamma Interaction — Full Descriptive Statistics: Bias",
    subtitle = "Scenario-level bias (mean signed bias per scenario) summarized across scenarios by treatment"
  ) %>%
  gt::cols_label(
    scenarios      = "N scenarios",
    mean_bias      = "Mean",
    sd_bias        = "SD",
    median_bias    = "Median",
    mad_bias       = "MAD",
    min_bias       = "Min",
    q1_bias        = "Q1",
    q3_bias        = "Q3",
    iqr_bias       = "IQR",
    max_bias       = "Max",
    mean_abs_bias  = "Mean |bias|",
    share_bias_neg = "Share bias < 0",
    share_bias_pos = "Share bias > 0"
  ) %>%
  gt::tab_options(data_row.padding = gt::px(1))

gtsave(gt_bias_descr, here::here("results/tbl_bias_descr.rtf"))

gt_bias_full_overall

# ---- Empirical SE (overall) ----
tab_gamma_empse_overall <- summ_gamma %>%
  dplyr::group_by(treatment) %>%
  dplyr::summarise(
    scenarios   = dplyr::n(),
    mean_emp_se = mean(emp_se, na.rm = TRUE),
    sd_emp_se   = sd(emp_se, na.rm = TRUE),
    .groups = "drop"
  )

gt_gamma_empse_overall <- tab_gamma_empse_overall %>%
  dplyr::mutate(
    mean_emp_se = scales::number(mean_emp_se, accuracy = 0.0001),
    sd_emp_se   = scales::number(sd_emp_se, accuracy = 0.0001)
  ) %>%
  gt::gt() %>%
  gt::tab_header(
    title = "Gamma Interaction — Descriptive Statistics: Empirical SE (All Scenarios)",
    subtitle = "Empirical SE = Monte Carlo SD of the estimator across replications"
  ) %>%
  gt::tab_options(data_row.padding = gt::px(1))

# Helper to get quantiles safely
q_fun <- function(x, p) stats::quantile(x, probs = p, na.rm = TRUE, type = 7)

tab_empse_full_overall <- summ_gamma %>%
  dplyr::group_by(treatment) %>%
  dplyr::summarise(
    scenarios       = dplyr::n(),
    mean_emp_se     = mean(emp_se, na.rm = TRUE),
    sd_emp_se       = sd(emp_se, na.rm = TRUE),
    median_emp_se   = median(emp_se, na.rm = TRUE),
    mad_emp_se      = mad(emp_se, na.rm = TRUE),
    min_emp_se      = min(emp_se, na.rm = TRUE),
    q1_emp_se       = q_fun(emp_se, 0.25),
    q3_emp_se       = q_fun(emp_se, 0.75),
    iqr_emp_se      = q3_emp_se - q1_emp_se,
    max_emp_se      = max(emp_se, na.rm = TRUE),
    .groups = "drop"
  )

gt_empse_full_overall <- tab_empse_full_overall %>%
  dplyr::mutate(
    dplyr::across(
      c(mean_emp_se, sd_emp_se, median_emp_se, mad_emp_se,
        min_emp_se, q1_emp_se, q3_emp_se, iqr_emp_se, max_emp_se),
      ~ scales::number(.x, accuracy = 0.0001)
    )
  ) %>%
  gt::gt() %>%
  gt::tab_header(
    title = "Gamma Interaction — Full Descriptive Statistics: Empirical SE",
    subtitle = "Scenario-level empirical SE (Monte Carlo SD of the estimator) summarised across scenarios by treatment"
  ) %>%
  gt::cols_label(
    scenarios = "N scenarios",
    mean_emp_se = "Mean",
    sd_emp_se = "SD",
    median_emp_se = "Median",
    mad_emp_se = "MAD",
    min_emp_se = "Min",
    q1_emp_se = "Q1",
    q3_emp_se = "Q3",
    iqr_emp_se = "IQR",
    max_emp_se = "Max"
  ) %>%
  gt::tab_options(data_row.padding = gt::px(1))

gt_empse_full_overall |> 
  gtsave(
    here::here("results/tbl_empse_descr.rtf")
  )

# ---- Coverage (overall) ----
tab_gamma_cov_overall <- summ_gamma %>%
  dplyr::group_by(treatment) %>%
  dplyr::summarise(
    scenarios       = dplyr::n(),
    mean_cov        = mean(coverage, na.rm = TRUE),
    p_cov_below_95  = mean(coverage < 0.95, na.rm = TRUE),
    .groups = "drop"
  )

gt_gamma_cov_overall <- tab_gamma_cov_overall %>%
  dplyr::mutate(
    mean_cov       = scales::percent(mean_cov, accuracy = 0.1),
    p_cov_below_95 = scales::percent(p_cov_below_95, accuracy = 0.1)
  ) %>%
  gt::gt() %>%
  gt::tab_header(
    title = "Gamma Interaction — Descriptive Statistics: Coverage (All Scenarios)",
    subtitle = "Nominal = 95%; table reports mean coverage and share of scenarios < 95%"
  ) %>%
  gt::tab_options(data_row.padding = gt::px(1))

# Stratified tables by prop_extreme * n * magnitude level 
# A tiny formatter for numeric columns
num4 <- function(x) scales::number(x, accuracy = 0.0001)

tab_cov_full_overall <- summ_gamma %>%
  dplyr::group_by(treatment) %>%
  dplyr::summarise(
    scenarios         = dplyr::n(),
    mean_cov          = mean(coverage, na.rm = TRUE),
    sd_cov            = sd(coverage, na.rm = TRUE),
    median_cov        = median(coverage, na.rm = TRUE),
    mad_cov           = mad(coverage, na.rm = TRUE),
    min_cov           = min(coverage, na.rm = TRUE),
    q1_cov            = q_fun(coverage, 0.25),
    q3_cov            = q_fun(coverage, 0.75),
    iqr_cov           = q3_cov - q1_cov,
    max_cov           = max(coverage, na.rm = TRUE),
    # policy-relevant shares around nominal 0.95
    p_cov_below_95    = mean(coverage < 0.95, na.rm = TRUE),
    p_cov_ge_95       = mean(coverage >= 0.95, na.rm = TRUE),
    .groups = "drop"
  )

gt_cov_full_overall <- tab_cov_full_overall %>%
  dplyr::mutate(
    # format coverage fields as percents where appropriate
    dplyr::across(
      c(mean_cov, sd_cov, median_cov, mad_cov, min_cov, q1_cov, q3_cov, iqr_cov, max_cov),
      ~ scales::percent(.x, accuracy = 0.1)
    ),
    p_cov_below_95 = scales::percent(p_cov_below_95, accuracy = 0.1),
    p_cov_ge_95    = scales::percent(p_cov_ge_95, accuracy = 0.1)
  ) %>%
  gt::gt() %>%
  gt::tab_header(
    title = "Gamma Interaction — Full Descriptive Statistics: Coverage",
    subtitle = "Scenario-level coverage summarised across scenarios by treatment (nominal: 95%)"
  ) %>%
  gt::cols_label(
    scenarios = "N scenarios",
    mean_cov = "Mean",
    sd_cov = "SD",
    median_cov = "Median",
    mad_cov = "MAD",
    min_cov = "Min",
    q1_cov = "Q1",
    q3_cov = "Q3",
    iqr_cov = "IQR",
    max_cov = "Max",
    p_cov_below_95 = "Share < 95%",
    p_cov_ge_95    = "Share ≥ 95%"
  ) %>%
  gt::tab_options(data_row.padding = gt::px(1))

gt_cov_full_overall

# Factory that returns a gt table for a given data frame + header labels
make_gt_table <- function(df, title, subtitle) {
  gt::gt(df) |>
    gt::tab_header(title = title, subtitle = subtitle) |>
    gt::tab_options(data_row.padding = gt::px(1))
}

num4 <- function(x) scales::number(x, accuracy = 0.0001)


tab_bias_stratified <- all_df_gamma %>%
  dplyr::group_by(treatment, prop_extreme, nobs, magnitude_level) %>%
  dplyr::summarise(
    scenarios      = dplyr::n(),
    mean_bias      = mean(bias, na.rm = TRUE),
    median_bias    = median(bias, na.rm = TRUE),
    mad_bias       = mad(bias, na.rm = TRUE),
    mean_abs_bias  = mean(abs(bias), na.rm = TRUE),
    .groups = "drop"
  ) %>%
  dplyr::mutate(
    mean_bias     = num4(mean_bias),
    median_bias   = num4(median_bias),
    mad_bias      = num4(mad_bias),
    mean_abs_bias = num4(mean_abs_bias)
  )

bias_tables_by_treatment <- tab_bias_stratified %>%
  dplyr::group_split(treatment)

gt_bias_by_treatment <- lapply(bias_tables_by_treatment, function(df) {
  trt <- df$treatment[1]

  make_gt_table(
    df %>% dplyr::select(-treatment),
    title = glue::glue("Gamma Interaction — Bias (All Scenarios)"),
    subtitle = glue::glue("Treatment = {trt}")
  )
})

for (i in seq_along(gt_bias_by_treatment)) { 
  trt <- unique(bias_tables_by_treatment[[i]]$treatment) 
  
  gt::gtsave( 
    gt_bias_by_treatment[[i]], 
    filename = here::here(paste0("results/tbl_bias_treatment_", trt, "_", dt, ".rtf"))
    ) }

```  

## Over/under estimation  

```{r over_underests}
# Replicate-level indicator of underestimation for gamma model
under_over_scen <- all_df_gamma %>%
  group_by(treatment, nobs, prop_extreme, magnitude_level) %>%
  summarise(
    n_under = sum(est < true, na.rm = TRUE), # count of underestimates 
    n_over = sum(est > true, na.rm = TRUE),
    under_rate = mean(est < true, na.rm = TRUE),
    over_rate  = mean(est > true, na.rm = TRUE),
    n_design=n(),
    .groups = "drop"
  ) |> 
  mutate(
    pct_under = scales::percent(under_rate, accuracy = 0.1),
    pct_over = scales::percent(over_rate, accuracy = 0.1)
  ) |> 
  ungroup() |> 
  select(treatment, n_design, nobs, prop_extreme, magnitude_level, n_under, n_over, pct_under, pct_over, under_rate, over_rate) |> 
  mutate(
     # 'consistently under' if majority of reps are < 0 bias in that scenario
    under_majority = under_rate > 0.5,
    over_majority  = over_rate > 0.5
  ) |>
  mutate(
    prop_extreme = as.numeric(prop_extreme),
    magnitude_level = as.numeric(magnitude_level),
    treatment = as.character(treatment)
  )

under_over_scen |> 
  arrange(nobs, prop_extreme, magnitude_level, treatment) |> 
  mutate(
    treatment = factor(
      treatment,
      levels = c("raw","topcode","mean_adj","median_adj","truncate"),
      labels = c("Raw","Top-coding", "Mean-preserved top-coding", "Median-preserved top-coding","Truncation"))
    ) |> 
  select(-c(under_rate, over_rate)) |> 
  gt() |> 
  gt::gtsave(
    here::here("results/tbl_over_under_scen.rtf")
)


# Aggregate to treatment-level “consistency” table
tab_consistency <- summ_gamma |>
  mutate(
    treatment = as.character(treatment)) |>
  left_join( 
    under_over_scen |> 
      mutate(prop_extreme = 
               case_when(prop_extreme == 1 ~ 0.01,
                         prop_extreme == 2 ~ 0.05,
                         prop_extreme == 3 ~ 0.10)),
    by = c("treatment",
      "nobs", 
      "prop_extreme",
      "magnitude_level")
    ) |>
  group_by(treatment) %>%
  summarise(
    n_scen = dplyr::n(),
    
    total_under = sum(n_under, na.rm = TRUE), # total reps underestimating 
    total_over = sum(n_over, na.rm = TRUE), # total reps overestimating 
    total_reps = sum(n_scen, na.rm = TRUE), # total reps across scenarios 
    
    avg_under_per_scen = mean(n_under, na.rm = TRUE), 
    avg_over_per_scen = mean(n_over, na.rm = TRUE),
    
    share_scen_under = mean(bias < 0, na.rm = TRUE),  
    # % scenarios with negative mean bias
    share_scen_over  = mean(bias > 0, na.rm = TRUE),
    share_scen_under_majority = mean(under_majority, na.rm = TRUE),
    .groups = "drop"
  )

gt_consistency <- tab_consistency %>%
  mutate(
    share_scen_under = scales::percent(share_scen_under, accuracy = 0.1),
    share_scen_over  = scales::percent(share_scen_over, accuracy = 0.1),
    share_scen_under_majority = scales::percent(
      share_scen_under_majority, accuracy = 0.1)
   #  mean_cov = scales::percent(mean_cov, accuracy = 0.1),
    # mean_emp_se = scales::number(mean_emp_se, accuracy = 0.0001)
  ) %>%
  gt::gt() %>%
  gt::tab_header(
    title = "Gamma Interaction: Consistency of Under/Over-Estimation by Treatment",
    subtitle = "Share of scenarios with negative mean bias and with majority underestimation"
  )

gt_consistency

gt::gtsave(
  gt_consistency,
    here::here("results/tbl_over_under_tx.rtf")
)
```    

```{r bias_by_scen}
scenario_summary <- under_over_scen |>
  group_by(nobs, prop_extreme, magnitude_level) |>
  summarise(
    n_treatments = n(),   # should equal number of treatments

    # counts of treatments that under/over
    n_treat_under = sum(under_rate > 0.5, na.rm = TRUE),
    n_treat_over  = sum(over_rate  > 0.5, na.rm = TRUE),

    # counts of treatments with majority under/over
    n_treat_under_majority = sum(under_majority, na.rm = TRUE),
    n_treat_over_majority  = sum(over_majority,  na.rm = TRUE),

    # proportions (denominator = number of treatments)
    prop_treat_under = n_treat_under / n_treatments,
    prop_treat_over  = n_treat_over  / n_treatments,
    prop_treat_under_majority = n_treat_under_majority / n_treatments,

    .groups = "drop"
  )

scenario_summary |> 
  gt() |> 
  gtsave(
    here::here("results/tbl_over_under_scen_summary.rtf")
  )

```



## Plots  

### Lollipop  

```{r lolly1}

prep_plot_bias_over_under <- summ_gamma |>
  left_join(
    under_over_scen |>
      mutate(
        prop_extreme = case_when(
          prop_extreme == 1 ~ 0.01,
          prop_extreme == 2 ~ 0.05,
          prop_extreme == 3 ~ 0.10
        )
      ),
    by = c("treatment", "nobs", "prop_extreme", "magnitude_level")
  ) |>
  mutate(
    nobs = factor(nobs, levels = c(5000, 10000, 20000)),
    prop_extreme = factor(prop_extreme, levels = c(0.01, 0.05, 0.10)),
    magnitude_level = factor(magnitude_level, levels = c(1, 2, 3)),
    treatment = factor(treatment),
    scenario = glue::glue("p={prop_extreme}, n={nobs}, m={magnitude_level}")
  ) |>
  arrange(nobs, prop_extreme, magnitude_level, treatment) |>
  mutate(
    scenario = factor(scenario, levels = rev(unique(scenario)))
  )

x_min <- min(prep_plot_bias_over_under$bias, na.rm = TRUE) # -0.024372
x_max <- max(prep_plot_bias_over_under$bias, na.rm = TRUE) # 0.10535



# table 
tab_27 <- prep_plot_bias_over_under |>
  group_by(treatment) |>
  summarise(
    n_scen = n(),   # should be 27

    scen_under = sum(bias < 0, na.rm = TRUE),
    scen_over  = sum(bias > 0, na.rm = TRUE),
    scen_under_majority = sum(under_majority, na.rm = TRUE),

    prop_scen_under = scen_under / 27,
    prop_scen_over  = scen_over  / 27,
    prop_scen_under_majority = scen_under_majority / 27,

    .groups = "drop"
  )

tab_27 |> 
  mutate(
    prop_scen_under = scales::percent(prop_scen_under, accuracy = 0.1),
    prop_scen_over  = scales::percent(prop_scen_over, accuracy = 0.1),
    prop_scen_under_majority = scales::percent(
      prop_scen_under_majority, accuracy = 0.1),
  ) |> 
  gt() |> 
  gtsave(here::here("results/tab_27.rtf"))


plots_bias <- prep_plot_bias_over_under |> 
  group_split(treatment) |> 
  map(~ { trt <- unique(.x$treatment) 
  ggplot(.x, aes(x = bias, y = scenario)) + 
    geom_segment(
      aes(x = 0, xend = bias, y = scenario, yend = scenario), 
      linewidth = 0.6, color = "grey60") + 
    geom_point(size = 3, color = "steelblue") + 
    scale_x_continuous(limits = c(x_min, x_max)) + 
    labs( x = "Bias", y = "Scenario (prop_extreme, nobs, magnitude_level)", 
          title = paste("Lollipop Chart of Bias — Treatment:", trt) ) +
    theme_minimal(base_size = 13) + 
    theme( panel.grid.major.y = element_blank(), 
           panel.grid.minor = element_blank(), 
           axis.text.y = element_text(size = 10), 
           plot.title = element_text(face = "bold"), 
           axis.title.y = element_blank() ) }
  )


plots_bias[[1]]
plots_bias

# df_plot |>
#   group_split(treatment) |>
#   walk(~ {
#     trt <- unique(.x$treatment)
# 
#     p <- ggplot(.x, aes(x = scenario, y = bias)) +
#       geom_segment(aes(x = scenario, xend = scenario, y = 0, yend = bias),
#                    linewidth = 0.6, color = "grey60") +
#       geom_point(size = 3, color = "steelblue") +
#       labs(
#         x = "Scenario",
#         y = "Bias",
#         title = glue::glue("Bias Across Scenarios — Treatment: {trt}")
#       ) +
#       theme_minimal(base_size = 13) +
#       theme(
#         panel.grid.major.x = element_blank(),
#         axis.text.x = element_text(size = 9, angle = 45, hjust = 1)
#       )
# 
#     print(p)
#   })


```


```{r plots_dir}

plot_bias_lollipop <- scenario_stats %>%
  group_by(treatment) %>%
  summarise(
    mean_of_means = mean(bias, na.rm = TRUE),
    sd_of_means   = sd(bias, na.rm = TRUE),
    .groups = "drop"
  ) %>%
  mutate(sign = ifelse(mean_of_means < 0, "Underestimation (−)", "Overestimation (+)"),
         treatment = forcats::fct_relevel(treatment, "raw","topcode","mean_adj","median_adj","truncate")) %>%
  ggplot(aes(x = treatment, y = mean_of_means, color = sign)) +
  geom_hline(yintercept = 0, linetype = "dashed") +
  geom_segment(aes(xend = treatment, y = 0, yend = mean_of_means), linewidth = 1.2) +
  geom_point(size = 3) +
  scale_color_manual(values = c("Underestimation (−)" = "#C7372F", "Overestimation (+)" = "#2B6CB0")) +
  labs(
    title = "Gamma Interaction: Average Scenario-Mean Bias by Treatment",
    subtitle = "Positive = overestimation; Negative = underestimation",
    x = NULL, y = "Average of scenario means (bias)"
  ) +
  theme_minimal() +
  theme(legend.position = "top")

plot_bias_lollipop
ggsave(here::here(paste0("figures/gamma_bias_lollipop_", dt, ".png")),
       plot_bias_lollipop, width = 8, height = 5, dpi = 300)
```  

### lollipop x2  
```{r lolli_v2}
# Reuse your scenario-level summary table for the Gamma interaction
summ_gamma <- summ_grid %>%
  dplyr::filter(model == "gamma") %>%
  dplyr::mutate(
    treatment = forcats::fct_relevel(
      treatment, "raw", "topcode", "mean_adj", "median_adj", "truncate"
    ),
    # scenario id string and absolute bias to plot
    scen_id = paste0("prop=", prop_extreme, " | mag=", magnitude_level, " | n=", n),
    abs_bias = abs(bias)
  )

# Option 1: one lollipop per scenario: 

make_lollipop <- function(df_one_scen) {
  scen_lab <- df_one_scen$scen_id[1]
  ggplot(df_one_scen, aes(x = abs_bias, y = treatment)) +
    geom_segment(aes(x = 0, xend = abs_bias, y = treatment, yend = treatment),
                 linewidth = 1.2, color = "grey55") +
    geom_point(size = 3, color = "#2B6CB0") +
    geom_text(aes(label = scales::number(abs_bias, accuracy = 0.0001)),
              nudge_x = 0.002, size = 3.1, hjust = 0) +
    labs(
      title = "Absolute Bias by Treatment (Scenario Lollipop)",
      subtitle = scen_lab,
      x = "Absolute bias |bias| (scenario mean across reps)",
      y = NULL
    ) +
    scale_x_continuous(expand = expansion(mult = c(0, .10))) +
    theme_minimal() +
    theme(panel.grid.major.y = element_blank())
}

# Split by scenario and save each plot
by_scenario <- split(summ_gamma, summ_gamma$scen_id)

for (nm in names(by_scenario)) {
  p <- make_lollipop(by_scenario[[nm]])
  out_path <- here::here(paste0("figures/lollipop_absbias_", gsub("[^A-Za-z0-9]+", "_", nm), "_", dt, ".png"))
  ggsave(out_path, p, width = 7.5, height = 4.5, dpi = 300)
}

```  

### Trend lines for how bias change with mag of extremes, prop of extremes 
```{r trend_lines}
# --- Trend lines including n as a scenario condition ---
# Treat magnitude level as numeric for trend fitting
scenario_stats_num <- scenario_stats %>%
  dplyr::mutate(
    mag = as.numeric(as.character(magnitude_level)),
    treatment = forcats::fct_relevel(treatment, "raw","topcode","mean_adj","median_adj","truncate"),
    n = as.factor(n)  # factor for clean facet labels
  )

plot_trends <- ggplot(
  scenario_stats_num,
  aes(x = mag, y = bias, color = treatment, group = treatment)
) +
  geom_hline(yintercept = 0, linetype = "dashed") +
  stat_summary(fun = mean, geom = "line", linewidth = 1.1) +
  stat_summary(fun = mean, geom = "point", size = 2) +
  facet_grid(n ~ prop_extreme, labeller = label_both) +
  scale_x_continuous(breaks = c(1, 2, 3), labels = c("1", "2", "3")) +
  labs(
    title = "Gamma Interaction: Trend in Mean Bias Across Magnitude of Extremes",
    subtitle = "Rows = n; Cols = proportion extreme; lines show scenario-means averaged at each magnitude level",
    x = "Magnitude level", y = "Scenario-mean bias"
  ) +
  theme_minimal() +
  theme(legend.position = "bottom")

plot_trends
ggsave(here::here(paste0("figures/gamma_bias_trends_", dt, ".png")),
       plot_trends, width = 11, height = 7, dpi = 300)
```

2C. Coverage heatmap vs nominal 0.95  
```{r plot_cov_heat}
plot_cov_heat <- summ_gamma %>%
  dplyr::mutate(
    treatment = forcats::fct_relevel(treatment, "raw","topcode","mean_adj","median_adj","truncate"),
    cell = paste0("prop=", prop_extreme, ", mag=", magnitude_level, ", n=", n)
  ) %>%
  ggplot(aes(x = treatment, y = cell, fill = coverage)) +
  geom_tile(color = "white") +
  scale_fill_gradient2(
    low = "#C7372F", mid = "white", high = "#2B6CB0",
    midpoint = 0.95, limits = c(0, 1), labels = scales::percent
  ) +
  labs(
    title = "Gamma Interaction: Coverage by Treatment and Scenario",
    subtitle = "Blue ≥ nominal 95%; red shows undercoverage; y-label encodes prop, mag, and n",
    x = "Treatment", y = "Scenario (prop, mag, n)", fill = "Coverage"
  ) +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 30, hjust = 1))

plot_cov_heat
ggsave(here::here(paste0("figures/gamma_coverage_heat_", dt, ".png")),
       plot_cov_heat, width = 11, height = 8, dpi = 300)
```  
2D. Consistency bars: % of scenarios with majority underestimation  
```{r fig_underest}

plot_under_consistency <- scenario_stats %>%
  group_by(treatment) %>%
  summarise(share_under_majority = mean(under_majority, na.rm = TRUE), .groups = "drop") %>%
  mutate(treatment = forcats::fct_relevel(treatment, "raw","topcode","mean_adj","median_adj","truncate")) %>%
  ggplot(aes(treatment, share_under_majority)) +
  geom_col(fill = "#C7372F") +
  geom_text(aes(label = scales::percent(share_under_majority, accuracy = 0.1)),
            vjust = -0.3) +
  scale_y_continuous(labels = scales::percent_format()) +
  labs(
    title = "Gamma Interaction: Consistency of Underestimation by Treatment",
    subtitle = "% of scenarios where >50% of reps underestimated",
    x = NULL, y = "% scenarios"
  ) +
  theme_minimal()

plot_under_consistency
ggsave(here::here(paste0("figures/gamma_under_consistency_", dt, ".png")),
       plot_under_consistency, width = 8, height = 5, dpi = 300)
```  

3. Auto-generate sentences  
Summarize direction, magnitude, reliability per treatment using tables above  
```{r sentences}
sentences <- tab_consistency %>%
  mutate(
    dir = ifelse(as.numeric(avg_mean_bias) < 0, "underestimated", "overestimated"),
    abs_avg = abs(as.numeric(avg_mean_bias)),
    txt = glue::glue(
      "On average across {n_scen} scenarios, the {treatment} method {dir} ",
      "the Gamma interaction by {scales::number(abs_avg, accuracy = 0.0001)}. ",
      "Median scenario-mean bias was {med_mean_bias}. ",
      "{scales::percent(share_scen_under, accuracy = 0.1)} of scenarios had negative mean bias, ",
      "and {scales::percent(share_scen_under_majority, accuracy = 0.1)} showed majority underestimation. ",
      "Mean empirical SE was {mean_emp_se}, and mean coverage was {scales::percent(mean_cov, accuracy = 0.1)}."
    )
  ) %>%
  dplyr::pull(txt)

cat(paste0("- ", sentences, collapse = "\n"))
```  

##4 FULL-FACTORIAL ANOVA (RQ answers)

```{r fn_aov_type3}
aov_type3_pes <- function(formula, data) {
  # Needed packages
  if (!requireNamespace("car", quietly = TRUE)) {
    stop("Please install the 'car' package for Type III SS.")
  }
  if (!requireNamespace("dplyr", quietly = TRUE)) {
    stop("Please install the 'dplyr' package.")
  }
  
  # Fit the model
  model <- aov(formula, data = data)
  
  # Type III ANOVA table
  a3 <- car::Anova(model, type = 3)
  # Convert to data frame
  tab <- as.data.frame(a3)
  tab$term <- rownames(tab)
  rownames(tab) <- NULL
  # Compute Mean Sq
  tab$`Mean Sq` <- tab$`Sum Sq` / tab$Df
  # Identify residual/error row
  error_row <- grepl("Residual", tab$term, ignore.case = TRUE)
  ss_error  <- tab$`Sum Sq`[error_row]
  # Compute partial eta squared
  tab$pes <- ifelse(
    !error_row,
    tab$`Sum Sq` / (tab$`Sum Sq` + ss_error),
    NA_real_
  )
  # Apply rounding rules
  tab_out <- tab |>
    dplyr::mutate(
      `Sum Sq`  = round(`Sum Sq`, 2),
      `Mean Sq` = round(`Mean Sq`, 2),
      `F value` = ifelse(!is.na(`F value`), round(`F value`, 2), NA_real_),
      `Pr(>F)` = dplyr::case_when(
        is.na(`Pr(>F)`) ~ NA_character_,
        round(`Pr(>F)`, 3) < 0.001 ~ "<.001",
        TRUE ~ sprintf("%.3f", round(`Pr(>F)`, 3))
      ),
      # partial eta squared: 3 decimals with <.001 rule
      pes = dplyr::case_when(
        is.na(pes) ~ NA_character_,
        round(pes, 3) < 0.001 & pes > 0 ~ "<.001",
        TRUE ~ sprintf("%.3f", round(pes, 3))
      )
    ) |>
    dplyr::select(term, Df, `Sum Sq`, `Mean Sq`, `F value`, `Pr(>F)`, pes)
  tab_out
}

```  




```{r}


# A) factorial ANOVA on gamma bias (rep-level)
aov_bias_t3_pes <- aov_type3_pes(
  bias ~ treatment * n * prop_extreme * magnitude_level, 
  data = all_df_gamma
)

fn_save_results(aov_bias_t3_pes)


# B) factorial ANOVA on gamma emp SE  (vs model SE, bc emp SE is the SD of the 500 est's of the coefficient, not the average of the model SE's, right?)
aov_empse_t3_pes <- aov_type3_pes(
  emp_se ~ treatment * n * prop_extreme * magnitude_level, 
  data = summ_grid_gamma )

fn_save_results(aov_empse_t3_pes)

# C) coverage: scenario-level proportion (recommended)
cov_grid <- all_df_gamma %>%
  group_by(treatment, n, prop_extreme, magnitude_level) %>%
  summarise(coverage = mean(cover_ind, na.rm = TRUE), .groups = "drop")

fn_save_results(cov_grid)

## Ask about this
aov_cov_scenario <- aov_type3_pes(
  coverage ~ treatment * n * prop_extreme * magnitude_level, 
  data = cov_grid
)

aov_gamma_cov <- aov(
  coverage ~ treatment * n * prop_extreme * magnitude_level, data = cov_grid)
aov_gamma_cov_t3 <- car::Anova(aov_gamma_cov, type = 3)
# summary(aov_gamma_cov)
# eta_squared(aov_gamma_cov, partial=TRUE) 

## ^^ effect size won't run because only one row per. Need to re-do: 


# --- Full factorial at replicate level now has residual df (many reps per cell) ---
aov_cov_t3_pes <- aov_type3_pes(
  cover_ind ~ treatment * n * prop_extreme * magnitude_level,
  data = all_df_gamma
  )

fn_save_results(aov_cov_t3_pes)


# ATT_hat across conditions (ignore the pes part)
aov_att_hat_t3 <- aov_type3_pes(
  est ~ treatment * n * prop_extreme * magnitude_level, 
  data = all_df_att
)
fn_save_results(aov_att_hat_t3)

# ATT_bias across conditions (recommended DV)
aov_att_bias_t3 <- aov_type3_pes(
  bias ~ treatment * n * prop_extreme * magnitude_level, 
  data = all_df_att
)
fn_save_results(aov_att_bias_t3)


# # Effect size (d_est) across conditions (optional but usually helpful)
# aov_att_d <- aov(d_est ~ treatment * n * prop_extreme * magnitude_level, data = all_df_att)
# summary(aov_att_d)


```  

## ANOVA effect-size reporting for eta-squared with p-values    

Reusable helper to extract eta-squared and p-values from an aov object  
This should pull p-values from `broom::tidy()` and eta-sq from `effectsize::eta_squared()`
which matches with how ANOVAs are already fit. 
```{r aov_eta_helper}
eta_with_p <- function(aov_obj, model_label,
                       type = c("eta2", "partial", "generalized"),
                       include_ci = TRUE, conf_level = 0.90) {
  type <- match.arg(type)

  # ---- 1) Get a tidy ANOVA table and a reliable p-value column ----
  # Try broom::tidy() first
  tab <- tryCatch(broom::tidy(aov_obj), error = function(e) NULL)

  if (is.null(tab)) {
    # Fallback: coerce to data.frame (works for car::Anova and aov objects)
    tab <- as.data.frame(aov_obj)
    # Move term names from rownames into a column
    tab <- tibble::rownames_to_column(tab, var = "term")
  }

  # Normalize the 'term' column name if broom gave a different label
  if (!("term" %in% names(tab))) {
    term_col <- grep("^term$|^Term$|^Effect$|^Parameter$", names(tab), value = TRUE)
    if (length(term_col) == 1L) names(tab)[names(tab) == term_col] <- "term"
  }

  # Identify/construct p-values:
  if (!("p.value" %in% names(tab))) {
    # Look for common alternatives like Pr(>F), Pr..F., etc.
    pv_alt <- grep("^Pr\\(>F\\)$|^Pr[.].*F[.]?$|^pval$|^p_value$", names(tab), value = TRUE)
    if (length(pv_alt) == 1L) {
      names(tab)[names(tab) == pv_alt] <- "p.value"
    } else {
      # As a last resort, try to compute p from F and dfs
      # Find F statistic and dfs
      f_col   <- grep("^F$|^F value$|^statistic$", names(tab), value = TRUE)
      df1_col <- grep("^df$|^Df1$|^num_df$|^num\\.df$", names(tab), value = TRUE)
      df2_col <- grep("^Df2$|^den_df$|^den\\.df$|^Residuals|^residual.df$|^error.df$", names(tab), value = TRUE)

      if (length(f_col) == 1L && length(df1_col) >= 1L && length(df2_col) >= 1L) {
        # Heuristic: If there is a single 'df' column, it might be numerator df; get denominator df from residuals row if present
        if (length(df1_col) == 1L && length(df2_col) == 1L) {
          Fval <- tab[[f_col]]
          df1  <- tab[[df1_col]]
          df2  <- tab[[df2_col]]
          tab$p.value <- stats::pf(Fval, df1, df2, lower.tail = FALSE)
        } else {
          # If structure is ambiguous, set NA and let the rest continue
          tab$p.value <- NA_real_
        }
      } else {
        tab$p.value <- NA_real_
      }
    }
  }

  # Keep only needed columns and drop residuals row if present
  tab_p <- tab %>%
    dplyr::filter(!is.na(term), term != "Residuals") %>%
    dplyr::select(term, p.value)

  # ---- 2) effect sizes from effectsize::eta_squared() ----
  ci_arg <- if (include_ci) conf_level else NULL
  es <- switch(
    type,
    eta2 = effectsize::eta_squared(aov_obj, ci = ci_arg),
    partial = effectsize::eta_squared(aov_obj, partial = TRUE, ci = ci_arg),
    generalized = effectsize::eta_squared(aov_obj, generalized = TRUE, ci = ci_arg)
  ) %>% as.data.frame()

  # Standardize common column names
  nm <- names(es)
  if ("Parameter" %in% nm) names(es)[nm == "Parameter"] <- "term"
  if ("Effect"    %in% nm) names(es)[nm == "Effect"]    <- "term"
  if ("Term"      %in% nm) names(es)[nm == "Term"]      <- "term"

  eta_col <- grep("^Eta2", names(es), value = TRUE)
  if (length(eta_col) == 1L) names(es)[names(es) == eta_col] <- "eta2"
  if ("CI_low"  %in% names(es)) names(es)[names(es) == "CI_low"]  <- "ci_low"
  if ("CI_high" %in% names(es)) names(es)[names(es) == "CI_high"] <- "ci_high"
  if (!("ci_low" %in% names(es))) {
    ci_low_guess <- grep("^CI[_\\.]?low", names(es), value = TRUE)
    if (length(ci_low_guess) == 1L) names(es)[names(es) == ci_low_guess] <- "ci_low"
  }
  if (!("ci_high" %in% names(es))) {
    ci_high_guess <- grep("^CI[_\\.]?high", names(es), value = TRUE)
    if (length(ci_high_guess) == 1L) names(es)[names(es) == ci_high_guess] <- "ci_high"
  }

  # ---- 3) Merge and label ----
  out <- dplyr::left_join(es, tab_p, by = "term") %>%
    dplyr::mutate(
      model  = model_label,
      es_type = switch(type, "eta2" = "eta^2", "partial" = "partial eta^2", "generalized" = "generalized eta^2"),
      stars = dplyr::case_when(
        !is.na(p.value) & p.value < .001 ~ "***",
        !is.na(p.value) & p.value < .01  ~ "**",
        !is.na(p.value) & p.value < .05  ~ "*",
        !is.na(p.value) & p.value < .10  ~ "†",
        TRUE ~ ""
      )
    ) %>%
    dplyr::select(model, es_type, term, eta2,
                  dplyr::any_of(c("ci_low", "ci_high")),
                  p.value, stars)

  out
}
```  

Apply to ANOVAs and build tables 
Groups rows by model (gamma bias, gamma coverage, ATT: bias), reports partial eta-eq, 90% CI, p-value, and sign. marks.

If we want Type II/III SS rather than the Type I default of `aov()`, can refit with `car::Anova()` and pass that object to `effectsize::eta_squared()`. (ASK TSAI)  

```{r}
# ---- Collect effect sizes for all models ----
es_eta2 <- dplyr::bind_rows(
  eta_with_p(aov_gamma_bias,   "Gamma bias",         "eta2"),
  eta_with_p(aov_gamma_emp_se, "Gamma empirical SE", "eta2"),
  eta_with_p(aov_gamma_cov,    "Gamma coverage",     "eta2"),
  eta_with_p(aov_att_hat,      "ATT: est",           "eta2"),
  eta_with_p(aov_att_bias,     "ATT: bias",          "eta2"),
  eta_with_p(aov_att_d,        "ATT: d_est",         "eta2")
)

es_partial <- dplyr::bind_rows(
  eta_with_p(aov_gamma_bias,   "Gamma bias",         "partial"),
  eta_with_p(aov_gamma_emp_se, "Gamma empirical SE", "partial"),
  eta_with_p(aov_gamma_cov,    "Gamma coverage",     "partial"),
  eta_with_p(aov_att_hat,      "ATT: est",           "partial"),
  eta_with_p(aov_att_bias,     "ATT: bias",          "partial"),
  eta_with_p(aov_att_d,        "ATT: d_est",         "partial")
)

es_gen <- dplyr::bind_rows(
  eta_with_p(aov_gamma_bias,   "Gamma bias",         "generalized"),
  eta_with_p(aov_gamma_emp_se, "Gamma empirical SE", "generalized"),
  eta_with_p(aov_gamma_cov,    "Gamma coverage",     "generalized"),
  eta_with_p(aov_att_hat,      "ATT: est",           "generalized"),
  eta_with_p(aov_att_bias,     "ATT: bias",          "generalized"),
  eta_with_p(aov_att_d,        "ATT: d_est",         "generalized")
)

# ---- Main table: partial eta^2 with p-values ----
tbl_partial <- es_partial %>%
  dplyr::mutate(
    eta2_fmt = ifelse(is.na(eta2), NA_character_, scales::number(eta2, accuracy = 0.0001)),
    ci_fmt = dplyr::if_else(
      is.na(ci_low) | is.na(ci_high), "—",
      paste0("[", scales::number(ci_low, accuracy = 0.0001), ", ",
                  scales::number(ci_high, accuracy = 0.0001), "]")
    ),
    p_fmt = ifelse(is.na(p.value), "—", scales::pvalue(p.value, accuracy = 0.001))
  ) %>%
  dplyr::select(model, term, `partial eta^2` = eta2_fmt, CI = ci_fmt, `p-value` = p_fmt, sig = stars)

gt_partial <- tbl_partial %>%
  gt::gt(groupname_col = "model") %>%
  gt::tab_header(
    title = gt::md("**ANOVA Effects: Partial η² with 90% CI and p-values**"),
    subtitle = "Design factors: treatment, n, prop_extreme, magnitude_level"
  ) %>%
  gt::tab_source_note("Signif.: *** < .001, ** < .01, * < .05, † < .10") %>%
  gt::cols_align(align = "center", columns = c(`partial eta^2`, CI, `p-value`, sig))

gt_partial
```  




